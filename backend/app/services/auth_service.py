"""
Authentication and user management service
"""

import jwt
from datetime import datetime, timedelta
from typing import Optional
from passlib.context import CryptContext
from passlib.hash import bcrypt
from loguru import logger

from app.services.base_service import BaseService
from app.models.auth_schemas import User, UserCreate, UserInDB, TokenData, UserRole
from app.core.config import settings


class AuthService(BaseService):
    """Authentication and user management service"""
    
    def __init__(self):
        super().__init__()
        
        # Password hashing
        self.pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
        
        # JWT settings
        self.secret_key = settings.SECRET_KEY
        self.algorithm = "HS256"
        self.access_token_expire_minutes = settings.ACCESS_TOKEN_EXPIRE_MINUTES
        
        # Mock user database (would be replaced with real database)
        self.mock_users_db = {
            "admin@turtletrading.com": {
                "id": 1,
                "email": "admin@turtletrading.com",
                "hashed_password": self.get_password_hash("admin123"),
                "full_name": "Admin User",
                "is_active": True,
                "role": UserRole.ADMIN,
                "created_at": datetime.utcnow(),
                "subscription_tier": "premium"
            },
            "user@turtletrading.com": {
                "id": 2,
                "email": "user@turtletrading.com", 
                "hashed_password": self.get_password_hash("user123"),
                "full_name": "Test User",
                "is_active": True,
                "role": UserRole.USER,
                "created_at": datetime.utcnow(),
                "subscription_tier": "free"
            }
        }
    
    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        """Verify a password against its hash"""
        try:
            return self.pwd_context.verify(plain_password, hashed_password)
        except Exception as e:
            logger.error(f"Error verifying password: {e}")
            return False
    
    def get_password_hash(self, password: str) -> str:
        """Generate password hash"""
        try:
            return self.pwd_context.hash(password)
        except Exception as e:
            logger.error(f"Error hashing password: {e}")
            raise ValueError("Error hashing password")
    
    async def get_user_by_email(self, email: str) -> Optional[UserInDB]:
        """Get user by email address"""
        try:
            # In production, this would query the database
            user_data = self.mock_users_db.get(email)
            if user_data:
                return UserInDB(**user_data)
            return None
        except Exception as e:
            logger.error(f"Error getting user by email {email}: {e}")
            return None
    
    async def get_user_by_id(self, user_id: int) -> Optional[UserInDB]:
        """Get user by ID"""
        try:
            # In production, this would query the database by ID
            for user_data in self.mock_users_db.values():
                if user_data["id"] == user_id:
                    return UserInDB(**user_data)
            return None
        except Exception as e:
            logger.error(f"Error getting user by ID {user_id}: {e}")
            return None
    
    async def authenticate_user(self, email: str, password: str) -> Optional[UserInDB]:
        """Authenticate user with email and password"""
        try:
            user = await self.get_user_by_email(email)
            if not user:
                return None
            
            if not self.verify_password(password, user.hashed_password):
                return None
            
            # Update last login
            user.last_login = datetime.utcnow()
            # In production, would update database
            
            return user
            
        except Exception as e:
            logger.error(f"Error authenticating user {email}: {e}")
            return None
    
    async def create_user(self, user_create: UserCreate) -> UserInDB:
        """Create new user"""
        try:
            # Check if user already exists
            existing_user = await self.get_user_by_email(user_create.email)
            if existing_user:
                raise ValueError("User already exists")
            
            # Create new user ID (in production, would be auto-generated by database)
            new_user_id = max(user["id"] for user in self.mock_users_db.values()) + 1
            
            # Hash password
            hashed_password = self.get_password_hash(user_create.password)
            
            # Create user data
            user_data = {
                "id": new_user_id,
                "email": user_create.email,
                "hashed_password": hashed_password,
                "full_name": user_create.full_name,
                "is_active": True,
                "role": UserRole.USER,
                "created_at": datetime.utcnow(),
                "last_login": None,
                "preferences": {},
                "subscription_tier": "free",
                "subscription_expires": None
            }
            
            # Store in mock database
            self.mock_users_db[user_create.email] = user_data
            
            return UserInDB(**user_data)
            
        except Exception as e:
            logger.error(f"Error creating user {user_create.email}: {e}")
            raise
    
    def create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None) -> str:
        """Create JWT access token"""
        try:
            to_encode = data.copy()
            
            if expires_delta:
                expire = datetime.utcnow() + expires_delta
            else:
                expire = datetime.utcnow() + timedelta(minutes=self.access_token_expire_minutes)
            
            to_encode.update({"exp": expire})
            
            encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
            return encoded_jwt
            
        except Exception as e:
            logger.error(f"Error creating access token: {e}")
            raise ValueError("Error creating access token")
    
    def decode_access_token(self, token: str) -> Optional[TokenData]:
        """Decode JWT access token"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            email: str = payload.get("sub")
            if email is None:
                return None
            
            return TokenData(email=email)
            
        except jwt.PyJWTError as e:
            logger.error(f"JWT decode error: {e}")
            return None
        except Exception as e:
            logger.error(f"Error decoding access token: {e}")
            return None
    
    async def get_current_user(self, token: str) -> Optional[User]:
        """Get current user from JWT token"""
        try:
            token_data = self.decode_access_token(token)
            if not token_data or not token_data.email:
                return None
            
            user = await self.get_user_by_email(token_data.email)
            if not user:
                return None
            
            # Convert to public User model
            return User(
                id=user.id,
                email=user.email,
                full_name=user.full_name,
                is_active=user.is_active,
                role=user.role,
                created_at=user.created_at,
                last_login=user.last_login,
                subscription_tier=user.subscription_tier
            )
            
        except Exception as e:
            logger.error(f"Error getting current user: {e}")
            return None
    
    async def get_current_user_optional(self, token: Optional[str] = None) -> Optional[User]:
        """Get current user (optional for endpoints that don't require auth)"""
        if not token:
            return None
        return await self.get_current_user(token)
    
    async def update_user(self, user_id: int, user_update: dict) -> UserInDB:
        """Update user information"""
        try:
            user = await self.get_user_by_id(user_id)
            if not user:
                raise ValueError("User not found")
            
            # Update fields
            for field, value in user_update.items():
                if hasattr(user, field) and value is not None:
                    setattr(user, field, value)
            
            # Update in mock database
            for email, user_data in self.mock_users_db.items():
                if user_data["id"] == user_id:
                    user_data.update(user_update)
                    break
            
            return user
            
        except Exception as e:
            logger.error(f"Error updating user {user_id}: {e}")
            raise
    
    async def update_password(self, user_id: int, new_password: str) -> bool:
        """Update user password"""
        try:
            user = await self.get_user_by_id(user_id)
            if not user:
                return False
            
            # Hash new password
            hashed_password = self.get_password_hash(new_password)
            
            # Update in mock database
            for user_data in self.mock_users_db.values():
                if user_data["id"] == user_id:
                    user_data["hashed_password"] = hashed_password
                    break
            
            return True
            
        except Exception as e:
            logger.error(f"Error updating password for user {user_id}: {e}")
            return False
    
    async def delete_user(self, user_id: int) -> bool:
        """Delete user account"""
        try:
            user = await self.get_user_by_id(user_id)
            if not user:
                return False
            
            # Remove from mock database
            email_to_remove = None
            for email, user_data in self.mock_users_db.items():
                if user_data["id"] == user_id:
                    email_to_remove = email
                    break
            
            if email_to_remove:
                del self.mock_users_db[email_to_remove]
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error deleting user {user_id}: {e}")
            return False
    
    async def is_admin(self, user: User) -> bool:
        """Check if user is admin"""
        return user.role == UserRole.ADMIN
    
    async def is_premium(self, user: User) -> bool:
        """Check if user has premium subscription"""
        return user.subscription_tier in ["premium", "pro"] or user.role == UserRole.ADMIN
    
    async def rate_limit_check(self, user_id: int, endpoint: str) -> bool:
        """Check rate limits for a specific user and endpoint"""
        try:
            # Mock rate limiting implementation
            # In production, would check Redis or database for current usage
            logger.debug(f"Rate limit check for user {user_id} on endpoint {endpoint}")
            return True  # Allow for demo purposes

        except Exception as e:
            logger.error(f"Error checking rate limits: {e}")
            return True  # Allow on error

    async def check_api_limits(self, user: User, endpoint: str) -> bool:
        """Check if user has exceeded API limits"""
        try:
            # For free tier, implement rate limiting
            if user.subscription_tier == "free":
                return await self.rate_limit_check(user.id, endpoint)

            # Premium users have higher limits
            return True

        except Exception as e:
            logger.error(f"Error checking API limits for user {user.id}: {e}")
            return True  # Allow on error
    
    async def log_api_usage(self, user_id: int, endpoint: str, response_time: float, status_code: int) -> bool:
        """Log API usage for analytics and billing"""
        try:
            # In production, would store in database
            usage_log = {
                "user_id": user_id,
                "endpoint": endpoint,
                "timestamp": datetime.utcnow(),
                "response_time": response_time,
                "status_code": status_code
            }
            
            logger.debug(f"API usage logged: {usage_log}")
            return True
            
        except Exception as e:
            logger.error(f"Error logging API usage: {e}")
            return False
    
    async def get_user_stats(self, user_id: int) -> dict:
        """Get user statistics and usage"""
        try:
            user = await self.get_user_by_id(user_id)
            if not user:
                return {}
            
            # Mock statistics (would query from database in production)
            account_age = (datetime.utcnow() - user.created_at).days
            
            return {
                "user_id": user_id,
                "total_api_calls": 150,  # Mock data
                "daily_api_calls": 25,   # Mock data
                "favorite_stocks": ["AAPL", "MSFT", "NVDA"],
                "last_analysis": datetime.utcnow() - timedelta(hours=2),
                "account_age_days": account_age,
                "subscription_tier": user.subscription_tier,
                "is_active": user.is_active
            }
            
        except Exception as e:
            logger.error(f"Error getting user stats for {user_id}: {e}")
            return {}
    
    async def validate_subscription(self, user: User) -> bool:
        """Validate user subscription status"""
        try:
            if user.subscription_tier == "free":
                return True  # Free tier always valid
            
            # For premium subscriptions, would check expiry date
            # This is simplified for demo
            return user.is_active
            
        except Exception as e:
            logger.error(f"Error validating subscription for user {user.id}: {e}")
            return False
    
    async def health_check(self) -> dict:
        """Auth service health check"""
        base_health = await super().health_check()
        
        # Add auth-specific health checks
        base_health.update({
            "users_count": len(self.mock_users_db),
            "jwt_configured": bool(self.secret_key),
            "password_hashing": "bcrypt"
        })
        
        return base_health